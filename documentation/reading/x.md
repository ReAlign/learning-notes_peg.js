# PEG.js

## 语法

### 规则

```pegjs
规则名称 "易于理解的规则别名" = 解析表达式
```

说明

* 每个规则都有一个 **标识该规则的名称** 和一个 **解析表达式**，该 **解析表达式** 定义一个 **模式** 以与输入文本进行匹配，并且可能包含 `JavaScript` 代码，这些代码确定模式成功匹配后会发生什么。
* 规则还可以包含错误消息中使用的易于理解的名称
* 解析从第一个规则（也称为开始规则）开始
* 规则名称必须是JavaScript标识符

### 初始化程序

第一个规则可以带有一个初始化程序，即一段大括号（“ {”和“}”）中的JavaScript代码。

* 在生成的解析器开始解析之前，将执行此代码
* 可以在规则操作和语义谓词中访问初始化程序中定义的所有变量和函数
* 初始化器中的代码可以使用options变量访问传递给解析器的选项
* 初始化代码中的花括号必须保持平衡

### 解析表达式

用于将输入文本与语法进行匹配

如果表达式在运行生成的解析器时成功匹配文本的一部分，则将生成匹配结果，这是一个JavaScript值。例如：

* 与文字字符串匹配的表达式会生成包含匹配文本的JavaScript字符串。
* 与某个子表达式的重复出现匹配的表达式将生成具有所有匹配项的JavaScript数组。

在表达式中使用规则名称时，匹配结果会通过规则传播，直到起始规则为止。解析成功后，生成的解析器将返回起始规则的匹配结果。

解析器表达式的一种特殊情况是解析器动作 -大括号（“ {”和“}”）中的一段JavaScript代码，该字符串获取前面某些表达式的匹配结果并返回JavaScript值。该值被认为是前一个表达式的匹配结果（换句话说，解析器操作是匹配结果转换器）。

在我们的算术示例中，有许多解析器动作。考虑表达中的动作digits:[0-9]+ { return parseInt(digits.join(""), 10); }。它以表达式[0-9] +的匹配结果作为参数，该结果是一个包含数字的字符串数组。它将数字连接在一起以形成数字，并将其转换为JavaScript number对象。

#### 解析表达式类型

> 解析表达式有几种类型，其中一些包含子表达式，因此形成递归结构。

##### 精确匹配

`"literal"`、`'literal'`

> 精确匹配一个字符，并将其作为字符串返回

* 字符串语法与JavaScript中的相同
* 后追加 `i`，匹配不区分大小写

##### 组匹配

`[characters]`

> 匹配一组字符，并将其作为字符串返回

* 可以使用与JavaScript字符串完全相同的方式对列表中的字符进行转义
* 字符列表还可以包含范围（例如，[a-z] 表示“所有小写字母”）
* 在字符前面加上^ 反转的字符集（例如，[^a-z]表示“除小写字母外的所有字符”）
* 后追加 `i`，匹配不区分大小写

##### 规则

`rule`

> 递归匹配规则的解析表达式，并返回其匹配结果

##### 表达式

`( expression )`

> 匹配子表达式并返回其匹配结果

* `expression *`
  * 匹配表达式的零个或多个重复，并在数组中返回其匹配结果
  * 匹配是贪婪的，即解析器尝试尽可能多地匹配表达式
  * 与正则表达式不同，没有回溯
* `expression +`
  * 匹配表达式的一个或多个重复，然后将其匹配结果返回到数组中
  * 匹配是贪婪的，即解析器尝试尽可能多地匹配表达式
  * 与正则表达式不同，没有回溯
* `expression ?`
  * 尝试匹配表达式
    * 如果匹配成功，则返回其匹配结果
    * 否则返回null
  * 与正则表达式不同，没有回溯
* `& expression`
  * 尝试匹配表达式
    * 如果匹配成功，则返回 undefined 并且不消耗任何输入
    * 否则认为匹配失败
* `! expression`
  * 尝试匹配表达式
  * 如果 undefined 匹配失败，则返回 并且不消耗任何输入
  * 否则认为匹配失败
* `& { predicate }`、`! { predicate }`
  * 谓词是一段JavaScript代码，就像在函数内部一样执行
  * 它获取前一个表达式中带标签的表达式的匹配结果作为其参数
  * 它应该使用该return语句返回一些JavaScript值
    * 如果返回的值true在布尔上下文中求值为，则只返回undefined而不消耗任何输入
    * 否则，返回0 。否则认为比赛失败
  * 谓词中的代码可以访问语法开头在初始化程序中定义的所有变量和函数。
  * 谓词内部的代码也可以使用该location功能访问位置信息。它返回这样的对象：
  ```
  {
  start: { offset: 23, line: 5, column: 6 },
  end:   { offset: 23, line: 5, column: 6 }
  }
  ```
  * 的start和end特性都指当前的分析位置。该offset属性包含偏移量作为从零开始的索引，line而column 属性包含行和列作为从一开始的索引。
  * 谓词中的代码还可以使用options变量访问传递给解析器的选项。
  * 请注意，谓词代码中的花括号必须保持平衡。
* `$ expression`
  * 尝试匹配表达式。如果匹配成功，则返回匹配的文本而不是匹配结果
* `label : expression`
  * 匹配表达式并记住给定标签下的匹配结果
  * 标签必须是JavaScript标识符
  * 带标签的表达式与动作一起使用时，可以通过动作的JavaScript代码访问保存的匹配结果。
* `expression1 expression2 ... expressionn`
  * 匹配一系列表达式，然后将它们的匹配结果返回到数组中。
* `expression { action }`
  * 匹配表达式。如果匹配成功，请执行操作，否则认为匹配失败。
  * 该动作是一段JavaScript代码，就像在函数内部一样执行
  * 它获取前一个表达式中带标签的表达式的匹配结果作为其参数
  * 该操作应使用该return语句返回一些JavaScript值。
  * 该值被认为是前面表达式的匹配结果。

为了指示错误，动作中的代码可以调用该 expected函数，这使解析器引发异常。该函数有两个参数-当前位置的期望描述和可选的位置信息（默认为 location返回的信息-参见下文）。该描述将用作引发异常消息的一部分。

动作中的代码也可以调用该error 函数，这也使解析器抛出异常。该函数具有两个参数-错误消息和可选的位置信息（默认为location返回的信息-参见下文）。该消息将由抛出的异常使用。

操作内部的代码可以访问语法开头在初始化程序中定义的所有变量和函数。操作代码中的花括号必须保持平衡。

动作中的代码也可以使用text函数访问表达式匹配的文本。

动作中的代码也可以使用location函数访问位置信息 。它返回这样的对象：

{
start: { offset: 23, line: 5, column: 6 },
end:   { offset: 25, line: 5, column: 8 }
}
该start属性指的是表达式开头的位置，该end属性指的是表达式结尾之后的位置。该offset属性包含偏移量作为从零开始的索引，line而column 属性包含行和列作为从一开始的索引。

动作中的代码还可以使用该options变量访问传递给解析器的选项。

请注意，动作代码中的花括号必须保持平衡。

expression1 / expression2 / ... / expressionn
尝试匹配第一个表达式，如果不成功，请尝试第二个，以此类推。返回第一个成功匹配的表达式的匹配结果。如果没有表达式匹配，则认为匹配失败。
